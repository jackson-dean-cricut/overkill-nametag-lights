#ifndef NAMETAG_MESSAGES_H
#define NAMETAG_MESSAGES_H

#include <Arduino.h>
#include <ArduinoJson.h>

namespace nametag {

// Message types for mesh network communication
enum class MessageType {
    STATE_UPDATE,    // Full state updates from clients
    COMMAND,         // Commands from bridge to clients
    CLIENT_EVENT,    // Button presses and other client events
    DISCOVERY        // Node discovery and role assignment
};

// Basic state information for a client device
struct ClientState {
    bool isOn;
    uint8_t hue;
    bool isColorCycling;
    uint8_t pattern;
    
    // Serialize to JSON
    void toJson(JsonDocument& doc) const {
        doc["isOn"] = isOn;
        doc["hue"] = hue;
        doc["isColorCycling"] = isColorCycling;
        doc["pattern"] = pattern;
    }
    
    // Deserialize from JSON
    void fromJson(const JsonDocument& doc) {
        isOn = doc["isOn"] | false;
        hue = doc["hue"] | 0;
        isColorCycling = doc["isColorCycling"] | false;
        pattern = doc["pattern"] | 0;
    }
};

// Event generated by client devices
struct ClientEvent {
    uint8_t buttonIndex;
    enum class Action {
        CLICKED,
        DOUBLE_CLICKED,
        LONG_PRESSED,
        LONG_PRESS_RELEASED
    } action;
    
    // Serialize to JSON
    void toJson(JsonDocument& doc) const {
        doc["buttonIndex"] = buttonIndex;
        doc["action"] = static_cast<int>(action);
    }
    
    // Deserialize from JSON
    void fromJson(const JsonDocument& doc) {
        buttonIndex = doc["buttonIndex"] | 0;
        action = static_cast<Action>(doc["action"] | 0);
    }
};

// Command structure for bridge->client communication
struct Command {
    enum class Type {
        SET_ANIMATION,
        SET_STATE,
        RESET,
        SYNC_TIME
    } type;
    
    // Command parameters stored as JSON
    StaticJsonDocument<200> params;
    
    // Serialize to JSON
    void toJson(JsonDocument& doc) const {
        doc["type"] = static_cast<int>(type);
        doc["params"] = params;
    }
    
    // Deserialize from JSON
    void fromJson(const JsonDocument& doc) {
        type = static_cast<Type>(doc["type"] | 0);
        JsonObject paramsObj = doc["params"];
        if (paramsObj) {
            params.set(paramsObj);
        }
    }
};

// Helper to create a message packet
template<typename T>
void createMessagePacket(JsonDocument& doc, MessageType type, const T& payload) {
    doc["type"] = static_cast<int>(type);
    doc["timestamp"] = millis();  // Simple timestamp for now
    JsonObject data = doc.createNestedObject("data");
    payload.toJson(data);
}

} // namespace nametag

#endif // NAMETAG_MESSAGES_H